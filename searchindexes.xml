<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>关于我</title><url>/about/</url><categories/><tags/><content type="html">绰号: 三日(sanri)
邮箱: engineer_tang@qq.com</content></entry><entry><title>macOS下使用CLion远程开发调试Linux上的QtGUI程序</title><url>/posts/macos%E4%B8%8B%E4%BD%BF%E7%94%A8clion%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95linux%E4%B8%8A%E7%9A%84qtgui%E7%A8%8B%E5%BA%8F/</url><categories><category>笔记</category></categories><tags><tag>Qt</tag><tag>GUI</tag><tag>CLion</tag><tag>macOS</tag><tag>Linux</tag></tags><content type="html"><![CDATA[在macOS下使用CLion集成开发环境,配合macOS的X11环境XQuartz, 实现在macOS下编码,调试. 在远程Linux主机上编译,运行Qt程序. 并通过SSH的X11转发功能在macOS上显示程序界面.
由于需要开发Linux下的GUI程序,但是又不喜欢使用Linux的桌面环境, 适逢CLion2018.3新增远程开发功能,尝试了一下,嗯,可以远程构建并调试QtGUI程序.
开发环境 macOS 10.14.1 : XQuartz 2.7.11, CLion 2018.3, Qt5.9.7
Ubuntu Server 18.04 : gcc/g++ 7.3.0, gdb 8.1, Qt 5.9.5, cmake 3.10
实现原理 CLion在2018.3版中新增了远程开发功能(这个功能都被呼吁好几年了,现在终于补上了).
虽然按照 官方说明 就可以开发一般的控制台程序了,但是还不能直接开发GUI程序.
因为CLion与目标系统间的连接,并没有进行X11转发,所以理论上只需要配置好X11转发通道,再提供一个X11 Server,就能显示GUI程序了.
首先macOS下有XQuartz程序,这样X11 Server有了.
然后在macOS下的控制台,使用ssh程序登录目标Linux系统(带 -X 选项),这样就有了X11转发通道.
最后在CLion中配置项目,在启动目标Linux系统上的程序时,提供X11 Server的地址(程序通过环境变量DISPLAY获取X11 Server地址),这样就可以成功启动并调试目标程序啦.
准备开发环境 macOS 安装 CLion 2018.3 CLion 的 远程构建 功能是2018.3版本新加入的, 远程调试 功能比较早就实现了, 不过这次没有使用老版本的远程调试功能.
安装 XQuartz 最新版本是2.8.1.
安装 Qt 主要是需要使用 Qt Designer 工具, 不使用工具,手写 ui 文件也可以.
Ubuntu 安装构建工具 sudo apt install gcc g++ gdb cmake 安装Qt sudo apt install qtbase5-dev qt5-default qtdeclarative5-dev qttools5-dev 创建项目 首先建立一个C++项目,使用C++11标准.
新建 qttest.h, qttest.cpp 文件.
// qttest.h #ifndef QT_TEST_H #define QT_TEST_H #include &lt;QWidget&gt; #include &#34;ui_qttest.h&#34; class qttest : public QWidget { Q_OBJECT public: qttest(QWidget *parent = 0); ~qttest(); private: Ui::qttest_ui ui; }; #endif // QT_TEST_H // qttest.cpp #include &#34;qttest.h&#34; qttest::qttest(QWidget *parent) : QWidget(parent) { ui.setupUi(this); } qttest::~qttest() { } 使用 Qt Designer 程序新建 qttest.ui文件,注意窗口对象的名称需要与 qttest.h 中ui对象的类型名一致 改写 main.cpp 文件
#include &#34;qttest.h&#34; #include &lt;QtWidgets/QApplication&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); qttest w; w.show(); return a.exec(); } 编辑 CMakeLists.txt 文件
cmake_minimum_required(VERSION 3.10) set(CMAKE_CXX_STANDARD 11) # 自动将当前源代码和构建目录添加到包含路径 set(CMAKE_INCLUDE_CURRENT_DIR ON) # 指示CMake在需要时自动运行moc set(CMAKE_AUTOMOC ON) # 兼容macOS下构建 if(APPLE) message(&#34;apple\n&#34;) set(CMAKE_PREFIX_PATH /Users/tang/Qt/5.9.7/clang_64) set(QLIBDIR &#34;/Users/tang/Qt/5.9.7/clang_64/lib&#34; ) endif(APPLE) project(qttest) # 查找QtWidgets包 find_package(Qt5Widgets) #从ui文件创建cpp代码 qt5_wrap_ui(ui_qttest.h qttest.ui) add_executable(qttest main.cpp qttest.cpp qttest.ui) target_link_libraries( qttest Qt5::Widgets ) 配置CLion 进入 Preferences/Build,Execution,Deployment/Toolchains 页面 选择 Remote Host 选项 增加一个工具链并配置目标系统登录选项 Credentials 然后配置工具链路径,配置完成后如图所示 进入 Preferences/Build,Execution,Deployment/CMake 页面 添加一个配置, Toolchain 选项要选择之前配置的远程工具链 在macOS启动XQuartz程序,然后在终端下使用 ssh -X ubuntu@192.168.56.101 命令登录Ubuntu系统 登陆后,使用 echo $DISPLAY 命令查看 X11 服务器的转发地址,我的地址为 &ldquo;localhost:10.0&rdquo; 在CLion下,进入项目配置页面 编辑 Environment variables ,新增 DISPLAY 变量 编译并运行程序 配置都完成后,就可以编译程序了. 编译完成后的运行效果如图 如果程序启动失败,控制台输出
qt.qpa.screen: QXcbConnection: Could not connect to display localhost:10.0 Could not connect to any X display. Process finished with exit code 1 那是因为X11 Server 连接已经断开,使用 ssh -X ubuntu@192.168.56.101 命令重新登录Ubuntu即可解决.
]]></content></entry><entry><title>Windows中使用Qt5.9.0静态库构建应用</title><url>/posts/windows%E4%B8%AD%E4%BD%BF%E7%94%A8qt5.9.0%E9%9D%99%E6%80%81%E5%BA%93%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8/</url><categories><category>笔记</category></categories><tags><tag>Qt</tag><tag>GUI</tag></tags><content type="html"><![CDATA[在Windows下使用VS2015和CMake构建基于 Qt5.9.0静态库的应用程序.
准备Qt5.9.0静态库 请参考文章 VisualStudio编译Qt5.9.0静态库 使用VS2015与Qt5.9.0静态库构建应用 安装插件Qt5Package或Qt Visual Studio Tools 首先确认VS2015安装有插件 Qt5Package 或者Qt官方的插件 Qt Visual Studio Tools 没有的话到 &ldquo;扩展和更新&rdquo; 中寻找这两个插件.
配置项目 使用插件提供的模板,为了使用静态库,需要增加以下配置:
在项目中找到main函数所在文件,在文件开头插入下面的代码,用于导入平台扩展库的头文件 #include &lt;QtPlugin&gt; Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin) 在 &ldquo;链接器&rdquo; -&gt; &ldquo;常规&rdquo; -&gt; &ldquo;附加库目录&rdquo; 中,添加 &ldquo;$(QTDIR)\plugins\platforms&rdquo; 这个目录.这个目录中是平台扩展库.
在 &ldquo;链接器&rdquo; -&gt; &ldquo;输入&rdquo; -&gt; &ldquo;附加依赖项&rdquo; 中填写以下这些项.
debug版本
qtmaind.lib Qt5Cored.lib Qt5Guid.lib Qt5Widgetsd.lib Qt5PlatformCompositorSupportd.lib Qt5FontDatabaseSupportd.lib Qt5ThemeSupportd.lib Qt5AccessibilitySupportd.lib Qt5EventDispatcherSupportd.lib qtlibpngd.lib qtpcre2d.lib qtfreetyped.lib qtharfbuzzd.lib qminimald.lib qoffscreend.lib qwindowsd.lib qdirect2dd.lib imm32.lib winmm.lib Dwmapi.lib UxTheme.lib Mincore.lib version.lib ws2_32.lib release版本
qtmain.lib Qt5Core.lib Qt5Gui.lib Qt5Widgets.lib Qt5PlatformCompositorSupport.lib Qt5FontDatabaseSupport.lib Qt5ThemeSupport.lib Qt5AccessibilitySupport.lib Qt5EventDispatcherSupport.lib qtlibpng.lib qtpcre2.lib qtfreetype.lib qtharfbuzz.lib qwindows.lib qoffscreen.lib qdirect2d.lib qminimal.lib imm32.lib winmm.lib Dwmapi.lib UxTheme.lib Mincore.lib version.lib ws2_32.lib 根据使用的Qt5.9.0静态库的编译选项 MT 或 MD,在 &ldquo;代码生成&rdquo; -&gt; &ldquo;运行库&rdquo; 中选择 MT 或 MD.
设置完毕,编译通过就行了.
使用CMake与Qt5.9.0静态库构建Qt应用 概述 Qt5对CMake的支持相当好(或者反过来说CMake对Qt5的支持也很好),经过简单配置,CMake就可以做为Qt5的构建工具. 之前以为使用cmake构建qt应用会非常麻烦,需要自己调用moc和指定UI文件的编译过程.其实Qt5的库中已经提供方便使用cmake的模块与宏命令. 例如:
cmake 的CMAKE_AUTOMOC 变量,直接可以开启cmake在需要时自动运行moc功能. Qt5提供的cmake模块中, qt5_wrap_ui 宏可以直接从UI文件创建代码. 使用cmake的 target_link_libraries 命令,可以用这语法直接包含Qt的库文件 target_link_libraries( qt590static_test Qt5::Widgets ) 详情请参考Qt官方文档 Qt 5.9 CMake Manual 与CMake官方文档 cmake-qt 实例 创建文件 在项目目录中创建文件 qt590static_test.h.
// qt590static_test.h. #ifndef QT590STATIC_TEST_H #define QT590STATIC_TEST_H #include &lt;QtWidgets/QMainWindow&gt; #include &#34;ui_qt590static_test.h&#34; class qt590static_test : public QMainWindow { Q_OBJECT public: qt590static_test(QWidget *parent = 0); ~qt590static_test(); private: Ui::qt590static_testClass ui; }; #endif 创建文件 qt590static_test.cpp
// qt590static_test.cpp #include &#34;qt590static_test.h&#34; qt590static_test::qt590static_test(QWidget *parent) : QMainWindow(parent) { ui.setupUi(this); } qt590static_test::~qt590static_test() { } 使用Qt Designer 创建文件qt590static_test.ui. 也可以直接创建qt590static_test.ui文件
&lt;UI version=&#34;4.0&#34; &gt; &lt;class&gt;qt590static_testClass&lt;/class&gt; &lt;widget class=&#34;QMainWindow&#34; name=&#34;qt590static_testClass&#34; &gt; &lt;property name=&#34;objectName&#34; &gt; &lt;string notr=&#34;true&#34;&gt;qt590static_testClass&lt;/string&gt; &lt;/property&gt; &lt;property name=&#34;geometry&#34; &gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;600&lt;/width&gt; &lt;height&gt;400&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&#34;windowTitle&#34; &gt; &lt;string&gt;qt590static_test&lt;/string&gt; &lt;/property&gt; &lt;widget class=&#34;QMenuBar&#34; name=&#34;menuBar&#34; /&gt; &lt;widget class=&#34;QToolBar&#34; name=&#34;mainToolBar&#34; /&gt; &lt;widget class=&#34;QWidget&#34; name=&#34;centralWidget&#34; /&gt; &lt;widget class=&#34;QStatusBar&#34; name=&#34;statusBar&#34; /&gt; &lt;/widget&gt; &lt;layoutDefault spacing=&#34;6&#34; margin=&#34;11&#34; /&gt; &lt;pixmapfunction&gt;&lt;/pixmapfunction&gt; &lt;resources&gt; &lt;include location=&#34;qt590static_test.qrc&#34;/&gt; &lt;/resources&gt; &lt;connections/&gt; &lt;/UI&gt; 创建文件 main.cpp
// main.cpp #include &lt;QtPlugin&gt; Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin) #include &#34;qt590static_test.h&#34; #include &lt;QtWidgets/QApplication&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); qt590static_test w; w.show(); return a.exec(); } 创建CMake项目文件 CMakeLists.txt
cmake_minimum_required(VERSION 3.0.0) #设定Qt静态库的目录位置 set(CMAKE_PREFIX_PATH D:/Qt/Qt5.9.0_x64_static_msvc2015) #需要开启c++11标准 set(CMAKE_CXX_STANDARD 11) # 自动将当前源代码和构建目录添加到包含路径 set(CMAKE_INCLUDE_CURRENT_DIR ON) # 指示CMake在需要时自动运行moc set(CMAKE_AUTOMOC ON) # 查找QtWidgets包 find_package(Qt5Widgets) project(qt590static_test) #由于是使用静态库,所以需要指定部分链接库 set(QLIBDIR &#34;D:/Qt/Qt5.9.0_x64_static_msvc2015/lib/&#34;) set(QPLADIR &#34;D:/Qt/Qt5.9.0_x64_static_msvc2015/plugins/platforms/&#34;) if(CMAKE_BUILD_TYPE STREQUAL Debug) #Debug 版本需要链接的库 set(QLIBS ${QLIBDIR}Qt5PlatformCompositorSupportd.lib ${QLIBDIR}Qt5FontDatabaseSupportd.lib ${QLIBDIR}Qt5ThemeSupportd.lib ${QLIBDIR}Qt5AccessibilitySupportd.lib ${QLIBDIR}Qt5EventDispatcherSupportd.lib ${QLIBDIR}qtlibpngd.lib ${QLIBDIR}qtfreetyped.lib ${QLIBDIR}qtpcre2d.lib ${QLIBDIR}qtharfbuzzd.lib ${QPLADIR}qminimald.lib ${QPLADIR}qoffscreend.lib ${QPLADIR}qwindowsd.lib ${QPLADIR}qdirect2dd.lib ) elseif(CMAKE_BUILD_TYPE STREQUAL Release) #Release 版本需要链接的库 set(QLIBS ${QLIBDIR}Qt5PlatformCompositorSupport.lib ${QLIBDIR}Qt5FontDatabaseSupport.lib ${QLIBDIR}Qt5ThemeSupport.lib ${QLIBDIR}Qt5AccessibilitySupport.lib ${QLIBDIR}Qt5EventDispatcherSupport.lib ${QLIBDIR}qtlibpng.lib ${QLIBDIR}qtfreetype.lib ${QLIBDIR}qtpcre2.lib ${QLIBDIR}qtharfbuzz.lib ${QPLADIR}qminimal.lib ${QPLADIR}qoffscreen.lib ${QPLADIR}qwindows.lib ${QPLADIR}qdirect2d.lib ) else(CMAKE_BUILD_TYPE STREQUAL Debug) message(FATAL_ERROR &#34;please set CMAKE_BUILD_TYPE = Debug | Release&#34;) endif(CMAKE_BUILD_TYPE STREQUAL Debug) #从ui文件创建cpp代码,需要编译的UI文件都必须使用这条宏引入项目中 qt5_wrap_ui(ui_qt590static_test.h qt590static_test.ui) add_executable( qt590static_test WIN32 main.cpp qt590static_test.cpp qt590static_test.ui ) target_link_libraries( qt590static_test Qt5::Widgets ${QLIBS} imm32.lib winmm.lib Dwmapi.lib UxTheme.lib Mincore.lib version.lib ws2_32.lib ) 编译项目 使用 VS2015 x64 本机工具命令提示符 进入项目目录. 最好创建构建目录build_x64_Debug 与build_x64_Release,好分开构建Debug与Release版本.
进入构建目录,例如进入build_x64_Debug 后,执行命令:
cmake .. -G &#34;NMake Makefiles&#34; -DCMAKE_BUILD_TYPE=Debug 当然,也可以使用VS IDE,那么就使用命令:
cmake .. -G &#34;Visual Studio 14 2015 Win64&#34; -DCMAKE_BUILD_TYPE=Debug 编译项目,使用命令:
nmake 或者使用VS IDE打开项目并编译.
OK,构建成功
]]></content></entry><entry><title>VisualStudio编译Qt5.9.0静态库</title><url>/posts/visualstudio%E7%BC%96%E8%AF%91qt5.9.0%E9%9D%99%E6%80%81%E5%BA%93/</url><categories><category>笔记</category></categories><tags><tag>Qt</tag><tag>GUI</tag></tags><content type="html"><![CDATA[使用 VS2017或VS2015编译 Qt5.9.0的静态库
环境要求 大概内容就是需要软件 Perl 与 Python 支持, ANGLE 库非必要等等 详细内容请参考 Qt的官方文档 Qt for Windows - Requirements 构建步骤 1. 解压源代码压缩包 解压 qt-everywhere-opensource-src-5.9.0.zip 到构建目录,我这里是解压了两份源代码,方便编译x64与x86两种静态库.
2. 使用VS命令行 使用VS的命令行脚本 &ldquo;x64 Native Tools Command Prompt for VS 2017&rdquo; (VS2015中文版是 &ldquo;VS2015 x64 本机工具命令提示符&rdquo; )进入Qt源码目录. 如果编译x86的静态库,就用 &ldquo;x64_x86 Cross Tools Command Prompt for VS2017&rdquo; (VS2015中文版是 &ldquo;VS2015 x64 x86兼容工具命令提示符&rdquo; ).
3. 配置Qt库 运行命令
configure -prefix d:\libs\Qt\Qt5.9.0_x64_static_msvc2017 -opensource -debug-and-release -static -opengl dynamic -nomake examples -sql-sqlite -mp -prefix 选项是设定编译完成后,库的安装目录. 编译完成后的静态库,需要运行安装命令进行安装后,使用才比较方便. -opensource 选项是说明编译开源版本 -debug-and-release 选项说明同时编译debug与release版本, 我使用这个选项编译完成后,源码目录下占用了17G多的硬盘空间,心疼硬盘的就少编译点东西吧. -static 编译静态库,使用这个选项, Qt编译时的参数是 -MD与-MDd. 要改为 -MT 与 -MTd 就需要修改Qt的配置文件了. -opengl dynamic 设定Qt应用启动时, 动态加载opengl的驱动库,详情请参考 Qt for Windows - Requirements -nomake examples 不编译示例 -sql-sqlite 使用Qt内置的sqlite3插件 -mp 这个选项非常的好(此处鼓掌),使用VS的多处理器编译功能,就是多线程编译啦.保证能榨干你的CPU. 编译 上面的命令运行完且没有出错后,那就敲下神圣的字符
nmake 然后你可以喝杯咖啡,吃点零食, 喝杯红茶,出去溜达溜达,我是等了2个多小时才编译完.
安装 使用命令
nmake install 安装编译好的库.我安装好的库大概有3G左右.
结束 安装完成后, 你就可以开始撸代码, 你的老板也可以催你命啦 ^_^
]]></content></entry><entry><title>网站测试</title><url>/posts/%E7%BD%91%E7%AB%99%E6%B5%8B%E8%AF%95/</url><categories/><tags><tag>MathJax</tag><tag>Math</tag><tag>Mermaid</tag></tags><content type="html"><![CDATA[网站各项功能测试,标题测试,代码块
标题测试 三级标题 四级标题 五级标题 六级标题 代码块 cpp std::cout &lt;&lt; &#34;hello world !&#34; &lt;&lt; std::endl; rust fn main(){ println!(&#34;hello world !&#34;); } bash echo &#34;hello world !&#34; 数学公式 在线文档 MathJax $$ \sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t \tag{1} $$
$$ k_{n+1} = n^2 + k_n^2 - k_{n-1} \tag{2} $$
Mermaid 绘图 在线文档 Mermaid 流程图 graph TD; A-->B; A-->C; B-->D; C-->D; 时序图 sequenceDiagram participant Alice participant Bob Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts prevail! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! 状态图 stateDiagram-v2 [*] --> First state First { [*] --> second second --> [*] } 甘特图 gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d Git 分支图 %%{init: { 'logLevel': 'debug', 'theme': 'default' } }%% gitGraph commit branch develop commit tag:"v1.0.0" commit checkout main commit type: HIGHLIGHT commit merge develop commit branch featureA commit 实体关系图 erDiagram Customer ||--o{ Order : places Customer { string name string custNumber string sector } Order ||--|{ Line-Item : contains Order { int orderNumber string deliveryAddress } Line-Item { string productCode int quantity float pricePerUnit } C4部署图 C4Deployment title Deployment Diagram for Internet Banking System - Live Deployment_Node(mob, "Customer's mobile device", "Apple IOS or Android"){ Container(mobile, "Mobile App", "Xamarin", "Provides a limited subset of the Internet Banking functionality to customers via their mobile device.") } Deployment_Node(comp, "Customer's computer", "Microsoft Windows or Apple macOS"){ Deployment_Node(browser, "Web Browser", "Google Chrome, Mozilla Firefox, Apple Safari or Microsoft Edge"){ Container(spa, "Single Page Application", "JavaScript and Angular", "Provides all of the Internet Banking functionality to customers via their web browser.") } } Deployment_Node(plc, "Big Bank plc", "Big Bank plc data center"){ Deployment_Node(dn, "bigbank-api*** x8", "Ubuntu 16.04 LTS"){ Deployment_Node(apache, "Apache Tomcat", "Apache Tomcat 8.x"){ Container(api, "API Application", "Java and Spring MVC", "Provides Internet Banking functionality via a JSON/HTTPS API.") } } Deployment_Node(bb2, "bigbank-web*** x4", "Ubuntu 16.04 LTS"){ Deployment_Node(apache2, "Apache Tomcat", "Apache Tomcat 8.x"){ Container(web, "Web Application", "Java and Spring MVC", "Delivers the static content and the Internet Banking single page application.") } } Deployment_Node(bigbankdb01, "bigbank-db01", "Ubuntu 16.04 LTS"){ Deployment_Node(oracle, "Oracle - Primary", "Oracle 12c"){ ContainerDb(db, "Database", "Relational Database Schema", "Stores user registration information, hashed authentication credentials, access logs, etc.") } } Deployment_Node(bigbankdb02, "bigbank-db02", "Ubuntu 16.04 LTS") { Deployment_Node(oracle2, "Oracle - Secondary", "Oracle 12c") { ContainerDb(db2, "Database", "Relational Database Schema", "Stores user registration information, hashed authentication credentials, access logs, etc.") } } } Rel(mobile, api, "Makes API calls to", "json/HTTPS") Rel(spa, api, "Makes API calls to", "json/HTTPS") Rel_U(web, spa, "Delivers to the customer's web browser") Rel(api, db, "Reads from and writes to", "JDBC") Rel(api, db2, "Reads from and writes to", "JDBC") Rel_R(db, db2, "Replicates data to") UpdateRelStyle(spa, api, $offsetY="-40") UpdateRelStyle(web, spa, $offsetY="-40") UpdateRelStyle(api, db, $offsetY="-20", $offsetX="5") UpdateRelStyle(api, db2, $offsetX="-40", $offsetY="-20") UpdateRelStyle(db, db2, $offsetY="-10") 外部视频 bilibili <!DOCTYPE HTML> youtube ]]></content></entry></search>